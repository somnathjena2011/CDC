1. In each scope, a name can represent only a single entity. So, there cannot be two variables/functions/etc.. with the same name in the same scope.
e.g.
int main()
{
	int val;
	double val;//wrong, causes naming conflict
}
int val;//global scope
int main()
{
	int val;//local scope, ok
}

2. Namespace: Namespace allows us to group named entities into narrower scopes, which otherwise would have global scope.
3. Namespace is a declarative region that provides scope to the identifiers inside it.
4. Multiple namespace blocks with same name allowed. All declrations within those blocks are declared in the named scope.
5. syntax:
namespace name {
	// declarations/definitions
}
6. Namespace declarations appear only at global scope
7. Namespace declarations can be nested within another namespace
8. Namespace declarations don't have access specifiers(public or private)
9. No need of semicolon after namespace definition
10. We can split namespace definition over several units
e.g.
#include<iostream>
namespace ns{
	class Jeko;
}
class ns::Jeko{
public:
	void disp()
	{
		std::cout<<"India\n";
	}
};
int main()
{
	ns::Jeko jeko;
	jeko.display();
	return 0;
}
11. Multiple declarating blocks with same namespace name are called extending namespaces.
12. Unnamed namespaces:
->They are directly usable in the same program and are used for declaring unique identifiers.
->Name of namespace not mentioned in the defintion
->Name of unnamed namespace is uniquely generated by compiler
->Unnamed namespaces will only be accessible within the file it is defined
->Unnamed namespaces are the replacement for static declaration of variables
->Can't have two unnamed namespaces in same file, if we use 2 different blocks, one will be the extension of same unnamed namespace
e.g.
#include<iostream>
//unnamed namespace
namespace {
	int rel = 300;
}
int main()
{
	std::cout<<rel<<'\n';//prints 300
	return 0;
}
13. Declaring namespace in header files
//file1.h
namespace foo{
	int value()
	{
		return 5;
	}
}
//file.cpp
#include<iostream>
#include "file1.h"
using namespace std;
using namespace foo;
int main()
{
	cout<<value()<<'\n';
	return 0;
}
14. Namespaces can also be hierarchical
15. Alias can be used for namespace names
e.g.
#include<iostream>
using namespace std;
namespace ns1 {
	int val=5;
	namespace ns2 {
		int val=6;
	}
}
namespace alias = ns1::ns2;
int main()
{
	cout<<ns1::val<<'\n';
	cout<<alias::val<<'\n';
	return 0;
}
16. Inline namespaces
->Uses keyword inline in its definition
->If namespace N contains inline namespace M then members of M can be accessed via N directly
->This property is transitive. If N has inline namespace M, M has an inline namespace O, members of O can be used as though they were members of M or N.
17. Why "using namespace std;" is bad?
->std namespace has multiple(hundreds) of identifiers, definitions, etc
->If we intend to write our own definition of a function in a separate namespace(say of cout) and use cout in out program, then it will lead to conflict, so we won't be sure which namespace's cout is being acyually used/
->We can avoid writing long namespace resolutions using typedefs, using namespace inside functions instead of global.